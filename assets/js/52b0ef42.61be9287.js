"use strict";(self.webpackChunkidfive_docs=self.webpackChunkidfive_docs||[]).push([[8210],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>f});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return t?o.createElement(f,s(s({ref:n},p),{},{components:t})):o.createElement(f,s({ref:n},p))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<a;c++)s[c]=t[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9167:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var o=t(7462),r=(t(7294),t(3905));const a={},s="JavaScript/TypeScript",i={unversionedId:"front-end/js",id:"front-end/js",title:"JavaScript/TypeScript",description:"References",source:"@site/docs/front-end/js.md",sourceDirName:"front-end",slug:"/front-end/js",permalink:"/docs/front-end/js",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/front-end/js.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CSS/SCSS",permalink:"/docs/front-end/css"},next:{title:"Node.js",permalink:"/docs/front-end/node"}},l={},c=[{value:"References",id:"references",level:2},{value:"Type Assertion",id:"type-assertion",level:2},{value:"Type Hinting",id:"type-hinting",level:2},{value:"DOM Existence Checking",id:"dom-existence-checking",level:2},{value:"Performance",id:"performance",level:2},{value:"Functions",id:"functions",level:2},{value:"Modules",id:"modules",level:2},{value:"Named Exports",id:"named-exports",level:3},{value:"Default Exports",id:"default-exports",level:3},{value:"Multiple Exports",id:"multiple-exports",level:3},{value:"Component Design Pattern",id:"component-design-pattern",level:2},{value:"Component Options",id:"component-options",level:3}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"javascripttypescript"},"JavaScript/TypeScript"),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,"When declaring references, prefer ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," over ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," when possible. ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," prevents references from unintentionally being reassigned which can lead to bugs and side effects. When mutation is necessary, use ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," over ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"var")," should never be used as it uses function scoping instead of block scoping which is almost always preferable."),(0,r.kt)("h2",{id:"type-assertion"},"Type Assertion"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const menu = document.querySelector('.menu'); // Bad\nconst menu = <HTMLElement> document.querySelector('.menu'); //Okay\nconst menu = document.querySelector('.menu') as HTMLElement; // Better\n")),(0,r.kt)("h2",{id:"type-hinting"},"Type Hinting"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const isDone = false; // Okay\nconst isDone: boolean = false; // Better\n\nconst myNumber = 1; // Okay\nconst myNumber: number = 1; // Better\n\nconst myString = "Hello World"; // Okay\nconst myString: string = "Hello World"; // Better\n')),(0,r.kt)("h2",{id:"dom-existence-checking"},"DOM Existence Checking"),(0,r.kt)("p",null,"When selecting HTML elements, don't assume that they will always be present in the DOM. ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"},"Optional chaining")," was added in the ES2020 spec and provides by far the easiest way to check that an element is defined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Bad\nconst menu = document.querySelector('.menu') as HTMLElement;\nmenu.classList.add('menu--has-js');\n\n// Okay\nconst menu = document.querySelector('.menu') as HTMLElement;\nif (menu) {\n  menu.classList.add('menu--has-js');\n}\n\n// Better (with optional chaining)\nconst menu = document.querySelector('.menu') as HTMLElement;\nmenu?.classList.add('menu--has-js');\n")),(0,r.kt)("h2",{id:"performance"},"Performance"),(0,r.kt)("p",null,"Traversing the DOM is expensive. Save references to dom elements wherever possible."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Bad\nif (!document.querySelector(".menu")?.classList.contains("active")) {\n  document.querySelector(".menu").classList.add("active");\n}\n\n// Good\nconst menu = document.querySelector(".menu") as HTMLElement;\nif (!menu?.classList.contains("active")) {\n  menu.classList.add("active");\n}\n')),(0,r.kt)("p",null,"Onscroll event throttling."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'let lastKnownScrollPosition: number = 0;\nlet ticking: boolean = false;\n\nwindow.addEventListener("scroll", e => {\n  lastKnownScrollPosition = window.scrollY;\n  if (!ticking) {\n    window.requestAnimationFrame(() => {\n      doSomething(lastKnownScrollPosition);\n      ticking = false;\n    });\n    ticking = true;\n  }\n}, true);\n\nfunction doSomething(scrollPos) {\n  // Do something\n}\n')),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Optional parameters."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function doSomething(element: HTMLElement, isSpecial: boolean = false) {\n  const classToAdd  = isSpecial ? "special-class" : "normal-class";\n\n  if (!element?.classList.contains(classToAdd)) {\n    element.classList.add(classToAdd);\n  }\n\n  return element;\n}\n\ndoSomething(element); // Returns element with "normal-class" added\ndoSomething(element, true); // Returns element with "spacial-class" added\n')),(0,r.kt)("h2",{id:"modules"},"Modules"),(0,r.kt)("p",null,"Package code as re-usable modules."),(0,r.kt)("h3",{id:"named-exports"},"Named Exports"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"//----- sticky-element.ts -----/\nexport class StickyElement(element: HTMLElement) { ... }\n\n//----- index.ts -----/\nimport { StickyElement } from 'sticky-element';\n")),(0,r.kt)("h3",{id:"default-exports"},"Default Exports"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"//----- some-function.ts -----/\nexport default function() { ... }\n\n//----- index.ts -----/\nimport someFunction from 'some-function';\n")),(0,r.kt)("h3",{id:"multiple-exports"},"Multiple Exports"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"//----- some-related-functions.ts -----/\nfunction functionA() { ... }\nfunction functionB() { ... }\nexport { functionA, FunctionB };\n\n//----- index.ts -----/\nimport { functionB } from 'some-related-functions';\n")),(0,r.kt)("h2",{id:"component-design-pattern"},"Component Design Pattern"),(0,r.kt)("p",null,"A common pattern that we use for component definitions is to use an ES6 ",(0,r.kt)("inlineCode",{parentName:"p"},"class")," with the component's state and methods encapsulated within each instance. An example of this pattern is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export class Foo {\n  protected element: HTMLElement;\n  protected childElement: HTMLElement;\n  protected fooProperty: boolean;\n\n  public constructor(element: HTMLElement) {\n    if (element) {\n      this.element = element;\n      this.childElement = this.element.querySelector('.foo__child');\n      this.init();\n    }\n  }\n\n  protected init() {\n    // Initial setup code like binding event listeners, DOM manipulation, etc. goes here.\n  }\n}\n\n// Export a function that finds all components on load and instantiates a class instance for each node.\nexport function fooInit() {\n  const els = document.querySelectorAll('.foo');\n  for (let i = 0; i < els.length; i++) {\n    new Foo(els);\n  }\n}\n")),(0,r.kt)("h3",{id:"component-options"},"Component Options"),(0,r.kt)("p",null,"For certain components, you may want to pass an ",(0,r.kt)("inlineCode",{parentName:"p"},"options")," argument in addition to the ",(0,r.kt)("inlineCode",{parentName:"p"},"element")," argument to provide the ability to customize instances. To do this, it's helpful to create an ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," alongside your ",(0,r.kt)("inlineCode",{parentName:"p"},"class")," definition that defines the shape of this ",(0,r.kt)("inlineCode",{parentName:"p"},"options")," object. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface FooOptions {\n  fooProperty: boolean;\n  barOptionalProperty?: boolean;\n}\n\n// Optionally define a set of default property values to be used if values aren't provided.\nconst defaultOptions = {\n  fooProperty: true,\n} as FooOptions;\n\nexport class Foo {\n  protected element: HTMLElement;\n  protected options: FooOptions;\n\n  // Pass an empty object as the default value to later merge defaults into this.options.\n  public constructor(element: HTMLElement, options: FooOptions = {}) {\n    if (element) {\n      this.element = element;\n      // Merge in defaults and allow common/shared properties to be overridden by the values passed through args.\n      this.options = {\n        ...defaultOptions,\n        ...options,\n      };\n    }\n  }\n}\n")),(0,r.kt)("p",null,"With this defined as an ",(0,r.kt)("inlineCode",{parentName:"p"},"interface"),", you get the benefit of having editor autocomplete suggestions as you build out the object while also preventing properties that shouldn't be allowed on the object from being defined or providing properties that use incorrect types."))}u.isMDXComponent=!0}}]);