"use strict";(self.webpackChunkidfive_docs=self.webpackChunkidfive_docs||[]).push([[1120],{549:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"front-end/javascript-typescript","title":"JavaScript / TypeScript","description":"Style Guide, Pointers & Architecture","source":"@site/docs/front-end/06-javascript-typescript.md","sourceDirName":"front-end","slug":"/front-end/javascript-typescript","permalink":"/docs/front-end/javascript-typescript","draft":false,"unlisted":false,"editUrl":"https://github.com/idfive/Developer-Documentation/tree/main/docs/front-end/06-javascript-typescript.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"description":"Style Guide, Pointers & Architecture"},"sidebar":"tutorialSidebar","previous":{"title":"CSS","permalink":"/docs/front-end/css"},"next":{"title":"Fonts","permalink":"/docs/front-end/fonts"}}');var i=t(4848),o=t(8453);const r={description:"Style Guide, Pointers & Architecture"},c="JavaScript / TypeScript",l={},a=[{value:"Architecture",id:"architecture",level:2},{value:"No Refresh",id:"no-refresh",level:2},{value:"Verbose Code",id:"verbose-code",level:2},{value:"Variables",id:"variables",level:2},{value:"Type Assertion",id:"type-assertion",level:2},{value:"Type Hinting",id:"type-hinting",level:2},{value:"DOM Existence Checking",id:"dom-existence-checking",level:2},{value:"Performance",id:"performance",level:2},{value:"Functions",id:"functions",level:2},{value:"Modules",id:"modules",level:2},{value:"Named Exports",id:"named-exports",level:3},{value:"Default Exports",id:"default-exports",level:3},{value:"Multiple Exports",id:"multiple-exports",level:3},{value:"Component Design Pattern - Classes",id:"component-design-pattern---classes",level:2},{value:"Component Options",id:"component-options",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"javascript--typescript",children:"JavaScript / TypeScript"})}),"\n",(0,i.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsxs)(n.p,{children:["The entrypoint for all typescript modules is ",(0,i.jsx)(n.strong,{children:"main.ts"})," (located at ",(0,i.jsx)(n.strong,{children:"source/js/main.ts"}),"). Functions are imported here (for example ",(0,i.jsx)(n.code,{children:'import cardsInit from "./components/card";'}),") and then functions called below (",(0,i.jsx)(n.code,{children:"cardsInit();"}),")."]}),"\n",(0,i.jsx)(n.h2,{id:"no-refresh",children:"No Refresh"}),"\n",(0,i.jsx)(n.p,{children:"Using a site with functionality that changes on screen size should not require a browser refresh during that session. The user should be able to resize their screen at will and still be able to access all functionality of the website."}),"\n",(0,i.jsxs)(n.p,{children:["The following demonstrates setting up a typescript class which efficiently tracks resizing. In this example a media query variable is set to watch for a max-width of 768px. The ",(0,i.jsx)(n.code,{children:"init"})," method contains the ",(0,i.jsx)(n.code,{children:"handleResize"})," which contains methods that require detecting the resize."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const mobileMQ = window.matchMedia("(max-width: 768px)");\n\nprivate init() {\n  this.handleResize();\n}\n\nprivate handleResize() {\n  const resize = () => {\n    this.function(); // add methods here that require a change on resize\n  };\n  mobileMQ.addEventListener("change", resize);\n  resize();\n}\n\nprivate function() {\n  if(mobileMQ.matches) {\n    // mobile code\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"verbose-code",children:"Verbose Code"}),"\n",(0,i.jsx)(n.p,{children:"Prefer verbose over vague function and variable names."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let x = document.querySelector('.main-menu') as HTMLElement; /* Bad */\nlet mainMenu = document.querySelector('.main-menu') as HTMLElement; /* Good */\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function filter() {} /* Okay */\nfunction filterEvents() {} /* Better */\n"})}),"\n",(0,i.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,i.jsxs)(n.p,{children:["When declaring references, prefer ",(0,i.jsx)(n.code,{children:"const"})," over ",(0,i.jsx)(n.code,{children:"let"})," when possible. ",(0,i.jsx)(n.code,{children:"const"})," prevents references from unintentionally being reassigned which can lead to bugs and side effects. When mutation is necessary, use ",(0,i.jsx)(n.code,{children:"let"})," over ",(0,i.jsx)(n.code,{children:"const"}),". ",(0,i.jsx)(n.code,{children:"var"})," should never be used as it uses function scoping instead of block scoping which is almost always preferable."]}),"\n",(0,i.jsx)(n.h2,{id:"type-assertion",children:"Type Assertion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const menu = document.querySelector(".menu"); // Bad\nconst menu = <HTMLElement>document.querySelector(".menu"); //Okay\nconst menu = document.querySelector(".menu") as HTMLElement; // Better\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-hinting",children:"Type Hinting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const isDone = false; // Okay\nconst isDone: boolean = false; // Better\n\nconst myNumber = 1; // Okay\nconst myNumber: number = 1; // Better\n\nconst myString = "Hello World"; // Okay\nconst myString: string = "Hello World"; // Better\n'})}),"\n",(0,i.jsx)(n.h2,{id:"dom-existence-checking",children:"DOM Existence Checking"}),"\n",(0,i.jsxs)(n.p,{children:["When selecting HTML elements, don't assume that they will always be present in the DOM. ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining",children:"Optional chaining"})," was added in the ES2020 spec and provides by far the easiest way to check that an element is defined."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Bad\nconst menu = document.querySelector(".menu") as HTMLElement;\nmenu.classList.add("menu--has-js");\n\n// Okay\nconst menu = document.querySelector(".menu") as HTMLElement;\nif (menu) {\n  menu.classList.add("menu--has-js");\n}\n\n// Better (with optional chaining)\nconst menu = document.querySelector(".menu") as HTMLElement;\nmenu?.classList.add("menu--has-js");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,i.jsx)(n.p,{children:"Traversing the DOM is expensive. Save references to dom elements wherever possible."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// Bad\nif (!document.querySelector(".menu")?.classList.contains("active")) {\n  document.querySelector(".menu").classList.add("active");\n}\n\n// Good\nconst menu = document.querySelector(".menu") as HTMLElement;\nif (!menu?.classList.contains("active")) {\n  menu.classList.add("active");\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Onscroll event throttling."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'let lastKnownScrollPosition: number = 0;\nlet ticking: boolean = false;\n\nwindow.addEventListener(\n  "scroll",\n  (e) => {\n    lastKnownScrollPosition = window.scrollY;\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        doSomething(lastKnownScrollPosition);\n        ticking = false;\n      });\n      ticking = true;\n    }\n  },\n  true\n);\n\nfunction doSomething(scrollPos) {\n  // Do something\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.p,{children:"Optional parameters."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'function doSomething(element: HTMLElement, isSpecial: boolean = false) {\n  const classToAdd = isSpecial ? "special-class" : "normal-class";\n\n  if (!element?.classList.contains(classToAdd)) {\n    element.classList.add(classToAdd);\n  }\n\n  return element;\n}\n\ndoSomething(element); // Returns element with "normal-class" added\ndoSomething(element, true); // Returns element with "spacial-class" added\n'})}),"\n",(0,i.jsx)(n.h2,{id:"modules",children:"Modules"}),"\n",(0,i.jsx)(n.p,{children:"Package code as re-usable modules."}),"\n",(0,i.jsx)(n.h3,{id:"named-exports",children:"Named Exports"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"//----- sticky-element.ts -----/\nexport class StickyElement(element: HTMLElement) { ... }\n\n//----- index.ts -----/\nimport { StickyElement } from 'sticky-element';\n"})}),"\n",(0,i.jsx)(n.h3,{id:"default-exports",children:"Default Exports"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"//----- some-function.ts -----/\nexport default function() { ... }\n\n//----- index.ts -----/\nimport someFunction from 'some-function';\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-exports",children:"Multiple Exports"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"//----- some-related-functions.ts -----/\nfunction functionA() { ... }\nfunction functionB() { ... }\nexport { functionA, FunctionB };\n\n//----- index.ts -----/\nimport { functionB } from 'some-related-functions';\n"})}),"\n",(0,i.jsx)(n.h2,{id:"component-design-pattern---classes",children:"Component Design Pattern - Classes"}),"\n",(0,i.jsxs)(n.p,{children:["A common pattern that we use for component definitions is to use an ES6 ",(0,i.jsx)(n.code,{children:"class"})," with the component's state and methods encapsulated within each instance. An example of this pattern is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'export class Foo {\n  protected element: HTMLElement;\n  protected childElement: HTMLElement;\n  protected fooProperty: boolean;\n\n  public constructor(element: HTMLElement) {\n    if (element) {\n      this.element = element;\n      this.childElement = this.element.querySelector(".foo__child");\n      this.init();\n    }\n  }\n\n  protected init() {\n    // Initial setup code like binding event listeners, DOM manipulation, etc. goes here.\n  }\n}\n\n// Export a function that finds all components on load and instantiates a class instance for each node.\nexport function fooInit() {\n  const els = document.querySelectorAll(".foo");\n  for (let i = 0; i < els.length; i++) {\n    new Foo(els);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"component-options",children:"Component Options"}),"\n",(0,i.jsxs)(n.p,{children:["For certain components, you may want to pass an ",(0,i.jsx)(n.code,{children:"options"})," argument in addition to the ",(0,i.jsx)(n.code,{children:"element"})," argument to provide the ability to customize instances. To do this, it's helpful to create an ",(0,i.jsx)(n.code,{children:"interface"})," alongside your ",(0,i.jsx)(n.code,{children:"class"})," definition that defines the shape of this ",(0,i.jsx)(n.code,{children:"options"})," object. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export interface FooOptions {\n  fooProperty: boolean;\n  barOptionalProperty?: boolean;\n}\n\n// Optionally define a set of default property values to be used if values aren't provided.\nconst defaultOptions = {\n  fooProperty: true,\n} as FooOptions;\n\nexport class Foo {\n  protected element: HTMLElement;\n  protected options: FooOptions;\n\n  // Pass an empty object as the default value to later merge defaults into this.options.\n  public constructor(element: HTMLElement, options: FooOptions = {}) {\n    if (element) {\n      this.element = element;\n      // Merge in defaults and allow common/shared properties to be overridden by the values passed through args.\n      this.options = {\n        ...defaultOptions,\n        ...options,\n      };\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With this defined as an ",(0,i.jsx)(n.code,{children:"interface"}),", you get the benefit of having editor autocomplete suggestions as you build out the object while also preventing properties that shouldn't be allowed on the object from being defined or providing properties that use incorrect types."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);